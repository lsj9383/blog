# 微服务设计与运行

[TOC]

## 什么是微服务？

微服务是什么？

> 微服务应用是一系列自治服务的集合，每个服务只负责完成一块功能，这些服务共同合作来就可以完成某些更加复杂的操作。

与单体的复杂系统不同，开发者需要开发和管理一系列相对简单的服务，而这些服务可能以一些复杂的方式交互。

这是一个示例：

![](assets/epub_31151874_8.jfif)

微服务有有五大特性（微服务都能够满足下面的特性）：

特性 | 描述
-|-
单一职责 | 每个微服务只负责一个功能。这个功能可能是业务相关的功能，也可能是共用的技术功能，比如与第三方系统（如证券交易所）的集成。
数据库隔离 | 每个微服务都拥有自己的数据存储，如果有的话。这能够降低服务之间的耦合度，因为其他服务只能通过这个服务提供的接口来访问它们自己所不拥有的数据。
编排协作 | 微服务自己负责编排和协作，既不是由连接微服务的消息机制来完成的，也不是通过另外的软件功能来完成的。
独立部署 | 每个微服务都是可以独立部署的。如果做不到这一点，那么到了部署阶段，微服务应用还是一个庞大的单体应用。
可代替性 | 每个微服务都是可代替的。每个微服务只具备一项功能，所以这很自然地限制了服务的大小。同样，这也使得每个服务的职责或者角色更加易于理解。

微服务与传统 SOA 的区别：

> 微服务与传统的面向服务架构（SOA）在思想上的一个关键区别就是微服务负责协调系统中的各个操作，而SOA类型的服务通常使用企业服务总线（ESB）或者更复杂的编排标准来将应用本身与消息和流程编排拆分开。在SOA模型下，服务通常缺乏内聚性，因为业务逻辑会不断地被添加到服务总线上，而非服务本身。

## 微服务核心原则

支撑微服务开发的五大文化和架构原则：

原则 | 描述
-|-
自治性 | 每个服务的操作和修改都是独立于其他服务的。为了保证自治性，开发者需要将服务设计得松耦合、可独立部署。
可恢复性 | 微服务与生俱来地具备故障隔离的机制：如果开发者独立地部署这些微服务，那么当应用或者基础设施出现故障后，故障将只会影响到整个系统的一部分功能。
透明性 | 不管在什么时候，系统都应该是透明的、**可观测的**，这样既可以发现问题，也可以对问题进行诊断。
自动化 | 通过开发大批的服务来缓解应用不断变大所带来的痛苦，这看似是有悖常理的。事实上，相对于开发一个单体应用，微服务确实是一种更加复杂的架构。<br>通过采用自动化和在基础设施内保持服务之间的一致性，开发者可以极大地降低因这些额外的复杂性引入的管理代价。开发者需要使用自动化来保证部署和系统运维过程中的正确性。
一致性 | 开发者的目标应该是围绕业务概念来组织服务和团队，只有这样安排，服务和团队的内聚性才能更高。

上面五大原则可以带来的好处：

- 使系统更易于修改、扩展性和稳定性也更强。

## 为什么需要微服务？

**1. 技术性差异为微服务开路**

有一些公司同时采用了多种不同的技术，这使得微服务成为很自然的选择。

换而言之，就是对异构的技术进行解耦。

**2．开发冲突随着系统发展而增加**

软件系统天生就具有复杂性，没有哪种方法论或者架构能够消除系统核心的这种**本质复杂性（essential complexity）**。

开发者还是可以有所作为的，可以通过采用恰当的开发方案来确保开发出的是一套良好的复杂系统，而从那种**偶然复杂性（accidental complexity）**中解脱出来。

**3．微服务降低冲突和风险**

微服务通过三种方式来降低冲突和风险：

- 在开发阶段将依赖进行隔离和最小化。
- 开发者可以对单个的内聚组件进行思考，而非整个系统。
- 能够持续交付轻量的、独立的变更。

## 微服务的挑战

软件工程领域没有银弹，微服务也不例外。微服务在落地过程中会遇到很多挑战，常见的挑战有：

1. **识别和划定微服务范围**需要大量专业的业务领域知识。
1. 正确识别服务间的**边界和契约**是很困难的，而且一旦确定，是很难对它们进行改动的。
1. 微服务是**分布式系统**，所以需要对状态、一致性和网络可靠性这些内容做出不同的假设。
1. 跨网络分发系统组件以及不断增长的技术差异性，会导致微服务出现新的故障形式。
1. 越来越难以了解和验证在正常运行过程中会发生什么事情。

微服务并不能消除风险，而是将这个成本移到了软件生命周期的后半阶段，具体而言：

- 降低了开发过程中的冲突。
- 但是增加了运维阶段的复杂度，包括：
  - 部署，需要进行多个服务的部署，同时考虑各个依赖服务之间的部署方式。
  - 验证，一个功能需要联合多个服务配合才能验证。
  - 监控，一个服务需要多个功能的监控。

### 设计挑战

**1. 划定微服务范围需要业务领域知识**

每个微服务都只负责一个功能。识别这些功能需要丰富的业务领域知识。然而，在应用生命周期的初期，开发者的领域知识充其量是不够完整的，而最糟糕的情况下，开发者了解的这些知识可能是错误的。

和单体应用中的模块相比，微服务应用的服务边界更加僵化。这也就意味着，如果范围划定出错，可能给下游造成更高的代价：

![](assets/epub_31151874_23.jfif)

**注意：**

- 基于并不充分的业务领域知识做出设计决策的事情并不是微服务所独有的问题。区别只在于这些决策所造成的影响。
- 单体应用只是在应用内部划分模块，模块化错了并没有太严重的影响，最多涉及代码上的变更。访问、数据库等没有太多变化。

**2. 服务契约的维护**

每个微服务都应该独立于其他服务的实现方式。这样才能实现技术多样性和自治性。为了做到这一点，每个微服务应该对外暴露一个契约（类比于面向对象设计中的接口）。

一个的良好的契约设计应该具有以下特点：

1. 完整：定义了交互所需的全部内容。
1. 简洁：除了必需的信息，没有多余的内容，这样消费者就能在合理的范围内组装消息。
1. 可预测：准确反映了所有实现的真实表现。

**3．微服务应用是多个团队设计的**

要协调任何庞大的微服务应用的开发，都需要跨多个团队在优先级和实践层面达成一致。

**4．微服务应用是分布式系统**

关于分布式系统的设计，有许多谬论，其中包括：

- 网络是可靠的。
- 网络延迟为 0。
- 带宽是无限。
- 数据传输成本为 0。

开发者在非分布式系统中可以做出的那些假设（如方法调用的速度和可靠性）都不再合适，基于这些假设实现的系统会非常糟糕和不稳定。

开发者必须考虑到：

- 延迟性
- 可靠性
- 应用中的状态一致性

### 运维挑战

工程师会面对微服务的两大运维挑战：可观测性和多点故障。

**1．难以实现的可观测性**

为什么在微服务应用中，透明性会变得更困难呢？

这是因为开发者需要对整体有所了解。开发者需要将许许多多的碎片拼接起来形成整体的蓝图，所以需要将每个服务所生产的数据关联并连接到一起，进而在了解了交付商业价值整体的来龙去脉之后理解每个服务所做的工作。

每个服务的日志提供了系统运行的部分视图，这是很有用的，但是开发者需要同时从微观细节和宏观整体两方面来更加全面地理解这个系统。

**2．不断增加的服务使得故障点增多**

需要考虑如何让系统能够在单个组件出现问题的情况下继续运行。

这意味着，每个服务都需要更具鲁棒性（考虑到错误检查、故障切换、恢复），同样，整个系统也应该运行更加可靠，即便单个组件做不到100%的可靠。

## 微服务开发生命周期

我们会聚焦于微服务应用开发生命周期的三大阶段：

- 服务设计
- 将服务部署到生产环境中
- 功能监控

![](assets/epub_31151874_25.jfif)

### 微服务设计

在开发微服务应用时，开发者需要做出一些设计决策。这些设计决策在开发单体应用时并不会遇到。

开发者需要考虑以下问题：

1. 是从一个单体应用起步，还是一开始就使用微服务？
1. 应用的整体架构以及开放给外部消费者的接口。
1. 如何识别和划定服务的边界？
1. 服务之间是如何通信的？同步还是异步？
1. 如何实现服务的可恢复性？

### 微服务部署

在构建微服务时，开发和运维是相互交织在一起的。开发者将服务开发完成以后就当甩手掌柜，让其他人来部署和运维的方式是行不通的。

开发者需要做到两点：

- 其一，将微服务部署的人为操作标准化；
- 其二，实现持续交付的流水线。

### 服务监控

在生产环境中，开发者需要了解系统的运行情况。它的重要性有两点：

- 其一，开发者想要主动发现系统中的薄弱环节并进行重构；
- 其二，开发者需要了解系统的运行方式。
