# SimpleBank 示例

[TOC]

## 业务范围

每块业务领域都可能是由多个服务组成的，这些服务会相互协作，或者可能会与其他领域的服务进行协作。

不管是设计哪种系统，这种总览类型的领域模型都是不可或缺的第一步，但是在构建微服务时，这一步就显得至关重要。如果不解业务领域，设计人员就可能在划定服务边界时做出错误的决策。

没有人希望自己所构建的服务是贫血的——只是执行些琐碎的增删改查（CRUD）操作：

> 这些贫血的服务通常是导致系统内部耦合严重的源头之一。同时，我们要避免将太多的责任放到一个服务中，低内聚的服务会使得修改软件时效率更低，风险更大——而这恰恰是我们试图避免的。

## 微服务是否是正确的选择

软件架构设计总是牵涉到现实主义和理想主义的矛盾和冲突——要在产品需要、发展压力、团队能力这些方面进行平衡。

在选择微服务架构时所要考虑的影响因素：

影响因素 | 影响
-|-
业务领域复杂度 | 客观评价业务领域复杂度是个及其困难的事情，但是微服务能够解决受竞争压力所影响的系统复杂性问题。
技术需求 | 开发者可以使用不同的编程语言（以及对应的技术生态）来开发系统的不同组件。微服务使得技术选型更加多样化。
组织成长 | 快速成长的工程团队能够受益于微服务。
团队知识 | 许多工程师缺乏微服务和分布式系统的经验。

## 开发新功能

这是一个发布股票出售订单的例子，它由以下流程组成：

![](assets/epub_31151874_38.jfif)

在划定微服务范围时，开发者需要确保拆分系统所增加的复杂度不会超过所带来的益处。

**注意：**

- 或许之后，我们还会问，是将新增的功能添加到已有的服务，还是把这些服务拆分开？这些在后续进一步讨论。

正如我们前面所讨论的那样，每个服务应该只负责一个功能。那么第一步就是确定需要实现的不同业务功能以及它们之间的相互关系。

### 通过领域建模识别微服务

为了确定所需要的业务功能，开发者需要提高对所开发软件的业务领域的了解程度。

这通常是产品发掘或者业务分析中最难的工作：调查研究，原型设计，与客户、同事或其他终端用户进行访谈等。

我们对发布订单这一功能进行分析，发现实际上需要支持如下所有功能：

1. 记录出售订单的状态和历史
1. 将订单提交到市场上
1. 向客户收取下单的手续费
1. 在客户的账户记录交易信息
1. 向客户提供所持股份和订单的价值信息

我们了解到需要支持这些功能后，将紧密联系的功能放在一起，组成一个微服务。

**注意：**

- 并不是要绝对化地将每个功能都映射为单个微服务。
- 开发者需要判断哪些功能关系紧密——它们要放在一起。

将一组功能组合到一起，就形成了一个服务所要提供的能力（有些功能可能会跨越多个领域）：

![](assets/epub_31151874_40.jfif)

在最开始，可能领域并不是显而易见的，这时开发者可以直接将这些能力映射到微服务。每个服务应该体现业务所提供的能力，这样也就能实现体积和职责的平衡。

开发者还应该思考一下有哪些推动微服务在未来进行变化的因素——它是不是真的只有单一职责。

比如，开发者可能认为：市场操作是订单管理的子集，因此不应该分成两个服务。

但是经过我们的分析可知：

- 市场操作这个领域变化的驱动因素是所支持的市场的功能和范围
- 订单管理关联更紧密的是产品的类型以及进行交易的账户

所以这两个领域并不会同时变化，将他们放在一起并不是单一职责的。将这两块分开后，就区分了变化范围并且能最大限度地提升内聚性

**注意：**

- 单一职责的本质目的是隔离变化的原因。
- 微服务还有一个拆分维度是隔离变化的频率。

![](assets/epub_31151874_41.jfif)

此外，分解微服务并不应该过细，这是因为：

- 分解过细一方面会导致服务本身缺乏内聚。
- 关联比较紧密的协作服务之间耦合过紧（多个紧密的服务之间相互强耦合）
- 部署和监控太多的服务也会超出处于微服务实践初期的工程团队的工作能力

一条有用的经验就是宁可选择较大一些的服务，等功能变得更加特殊或者更加明确属于一个独立的服务时，再将功能从中拆分出去，这样会容易很多。

最后，牢记，了解业务领域并不是一蹴而就的过程！随着时间的推进，需要持续反复地去了解业务领域；用户的需求会变，产品也需要持续演进。随着对业务领域的了解的变化，系统本身也需要改变来满足这些要求。

### 服务协作

我们完成了服务的候选后，这些服务还需要进行协作才能完成 SimpleBank 的功能。

通常而言，服务协作有两种方式：

- 点到点方式，即同步方式。
- 事件驱动方式，即异步方式。

许多微服务应用起初使用的都是同步通信方式。之所以这么做，有如下两方面的原因。

- 同步调用通常要比异步通信更加简单而且更便于排查分析。
- 即便不是所有编程环境，至少大部分都已经支持一种简单、与语言无关而又在开发者中有广泛认知度的传输机制：HTTP。HTTP主要用于同步调用，但是也可以将其用于异步调用。

**注意：**

- 即便如此，也不要错误地认为它们和本地的进程内的函数调用有同样的特性——跨网络的请求明显要慢很多而且更加不可靠。

在我们的下单用例中，order 服务负责记录订单并将订单提交到市场。为此，它需要与 market 服务、fee 服务和 account transaction 服务进行交互。

![](assets/epub_31151874_42.jfif)

此外，开发者还需要注意**服务契约**和**服务职责**。

对于**服务契约：**

- 每个服务所接收的消息以及它返回的响应构成了服务与依赖该服务的上游协作服务之间的契约。
- 契约使得每个服务可以被它的协作方当作黑盒对待：发送一个请求，然后收到返回的某些结果。
- 虽然一个服务的实现会随着时间而变化，但是维持契约层面的兼容性能够保证两件事：
  - 这些变化不大会破坏消费者的使用；
  - 服务之间的依赖是可明确识别和可管理的。
- 根据我们的经验，契约通常隐含在微服务实现的早期或者初期。它们通常是通过文档或者惯例来体现的，而非显式地编纂成规范。

对于**服务职责**：

- order服务有许多职责。它直接操控下单流程所涉及的每个服务的动作。
- 从概念上讲这很简单，但是也有不利的一面：最差的情况下，那些被调用的服务会变成“贫血式”的服务，大部分傻瓜式的服务被少数的聪明服务所控制，而这些聪明的服务越来越大。
- 这种方式会导致服务间耦合越来越紧。如果开发者想要在下单流程中引入新的内容，开发者就必须将这部分修改部署到order服务中。这增加了修改的代价。

### 服务编排

在微服务应用中，服务自然会有不同层次的职责。但是开发者应该在编排（choreography）和编配（orchestration）之间进行平衡。

在编排式的系统中，服务不需要直接向其他服务发送命令和触发操作。相反，每个服务拥有特殊的职责，也就是对某些事件进行响应和执行操作。

我们重新看一下之前的设计并做些调整：

- （1）当有人创建订单时，可能还没开市，所以开发者需要记下订单的状态：创建成功，还是提交成功。订单提交发布的步骤并不需要同步。
- （2）只有订单提交成功，才会收取手续费，所以收取手续费的步骤也不需要同步。实际上，应该是响应market服务进而执行收费操作，而不是由order服务来安排收费。

![](assets/epub_31151874_43.jfif)

事件的增加也相应地增加了架构上要关注的内容：开发者需要采取某些方法来保存这些事件并将它们开放给其他系统。为此，我们建议使用 RabbitMQ 或 SQS 这样的消息队列。

在这个设计方案中，我们从order服务中移除了如下职责：

- （1）收费——order服务并不知道订单提交到市场以后还需要收费。
- （2）下单——order服务并不直接与market服务进行交互。
  - 这样，开发者可以很容易地用一种不同的实现方案进行替换，甚至于都可以改成每个市场对应一个 market 服务，而不需要对 order 服务进行任何修改。

这一方案要比之前的同步协作的方案复杂很多，但是：

- 在尽可能的情况下，采用这种编排的方案所开发的服务相互之间都是解耦的。
- 相应地，也就可以更独立地部署这些服务，修改这些服务也更容易。
- 但是有得就有失，我们也要付出一些代价：
  - 基础设施的队伍中又多了一个消息队列，我们需要持续地对其进行管理和扩容；
  - 它会成为一个单点故障源。

## 向外界开放服务

那么，我们如何将这些功能开放给真正的用户应用呢？

SimpleBank 公司希望同时开发网页端和移动端两个产品。为此，技术团队决定开发一个 API 网关，将其作为底层各个服务对外的门面。

这个网关会将各种各样的后端问题抽象化，这样，这些前端应用既不再需要了解底层的这些微服务的存在，也不需要了解为了完成各项功能这些微服务相互之间的交互方式。

API 网关会作为代理接管那些发给底层服务的请求，然后将底层服务的响应结果根据公开 API 的需要转换或者合并成新的数据格式。

API 网关提供下单功能以及与底层服务进行协作的过程如图所示：

![](assets/epub_31151874_45.jfif)

API 网关模式是一种很简洁的方式，但是它也有一些缺点：

- 因为作为众多底层服务唯一的组合对外入口，它会变得越来越大，而且可能会越来越笨重。
- 它会诱使开发者将业务逻辑添加到网关中，而非仅仅将其作为一个代理来对待。
- 它试图成为无所不能的可用于所有应用的服务，却又饱受其苦，毕竟不同应用的需求各有不同：
  - 移动客户端应用希望返回的数据体积更小、更精简。
  - 网页版的内部管理系统所需要的数据却又多得多。

在开发高度内聚的API时，开发者要同时平衡这些相互冲突是非常困难的。
