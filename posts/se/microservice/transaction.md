# 微服务的事务与查询

[TOC]

## 概览

许多单体应用在修改应用状态时都是依靠**事务**来保证一致性和隔离性的。要实现这两点很简单：

- 应用通常只和**单个数据库**交互，使用支持启动、提交和回滚这些事务操作的框架来实现强一致性保证。
- 每个业务逻辑事务会牵涉到许多不同的实体，比如下单操作会涉及更新交易记录、预定股票仓位和缴纳手续费。

在微服务应用中，每个独立服务只负责特定的功能，这也导致数据的所有权是去中心化的，每个数据源只有一个所有者。

这种方式的优点是：

- 这种层面的解耦有助于实现服务自治。

很明显，这给数据的各种操作带来了风险：

- 也牺牲了某些之前所具备的安全性，从而使得应用层面数据的一致性成为问题。
- 数据所有权的去中心化还使得数据的获取变得更加复杂：之前只需要在数据库层面进行关联的查询操作（JOIN）现在需要调用多个服务才能实现。在某些使用场景中，这还是能够接受的，但是当数据集特别大时，这种方案就会变得非常麻烦。
- 可用性同样会影响我们的应用设计。服务间的交互可能会失败，导致业务流程受阻，最终使整个系统处于不一致的状态。

在本章中，我们将介绍如何使用Saga来实现跨多个服务的复杂事务，并且还会探讨一些关于高效的数据查询的最佳实践。之后，我们还会研究一些基于事件消息的不同类型的架构（如事件溯源）以及它们在微服务应用中的适用范围。

## 分布式应用的事务一致性

设想一下，开发者是 SimpleBank 公司的一名客户，想卖出一些股票，这会让系统处理如下操作：

- 用户创建订单
- 应用验证
- 预定股票仓位
- 应用向用户收取手续费
- 应用将订单提交到市场上

![](assets/epub_31151874_125.jfif)

从客户的角度看，卖股票的操作看起来是原子性的：交手续费、股票预定和创建订单是同一时间发生的，用户不能卖自己没有的股票，也不能把自己的同一份股票连续买两次。

在许多单体应用中，这种需求很容易满足：可以将数据库操作封装在一个ACID的事务中，然后就高枕无忧了。因为开发者知道，如果中间出错，系统中的非法状态会被回滚回去。

在微服务应用中，每个操作都是由不同的服务来执行的，每个服务负责一部分应用状态。数据所有权的去中心化能有助于确保服务的独立性和松耦合，但是这也使得我们不得不在系统层面上提供一套机制来维护整体数据的一致性。

### 为什么不用分布式事务？

面对上面的问题，我们的第一个念头可能就是要设计一个能够在多个服务间实现事务保证的系统。

一种常见的方案就是使用二阶段提交（two phase commit，2PC）协议。在这种方案中，系统使用一个事务管理器（transaction manager）来将多个资源（resource）的操作分成两个阶段：准备（prepare）和提交（commit）。

![](assets/epub_31151874_128.jfif)

分布式事务的缺点：

- 事务管理器和资源方之间采用了同步的通信机制。如果某个资源方不可用，事务就不能提交而必须回滚。这反过来会增加重试的次数并且降低整个系统的可用性。
- 编配职责交给事务管理器同样违背了微服务的核心原则：服务自治。
- 分布式事务是通过给处于事务中的资源添加锁来确保隔离性的。这使得分布式事务不适合于那些耗时较长的操作，因为这会增加竞争和死锁的风险。

## 基于事件的通信

异步事件能够帮助我们解除服务之间的耦合和提高系统整体的可用性，这也促使服务的开发者开始思考最终一致性（eventual consistency）。

在采用最终一致性方案的系统中，开发者可以设计从多个独立的本地事务生成的复合型结果，这就需要为下层的各个资源明确设计各种暂时的状态。

这种设计方案将底层数据的可用性放在第一位。

### 同步方案

在同步方案中，order服务负责编配其他服务的行为，调用一系列的功能，最终订单被发布到市场上。

如果任何一个步骤出现故障，order 服务就负责启动其他服务的回滚操作，比如退回手续费。

![](assets/epub_31151874_131.jfif)

在这种方案中，order 服务承担了大量重要的职责：

- 它知道需要调用哪些服务以及调用这些服务的顺序；
- 在下游服务出错或者由于不符合业务规则而使下游服务不能正常处理时，它需要知道自己所要做的工作。

### 事件和编排

我们可以使用事件消息来重新设计这个场景。每个服务可以订阅它所感兴趣的事件消息，以确定何时必须执行工作：

![](assets/epub_31151874_132.jfif)

步骤如下：

1. 当用户通过界面发起出售请求时，应用发布一个 OrderRequested 事件。
1. order 服务接收这个事件后进行处理，然后向事件队列发出一个 OrderCreated 事件。
1. transaction 和 fee服务都会接收到这个事件通知，这两个服务会执行它们相应的操作，然后在执行完成以后分别发出一个通知事件。
1. market 服务等待两个通知事件：收费确认事件和股票预定成功事件。一旦接收到这两个事件，market 服务就可以向股票交易市场提交订单了。这步操作完成后，market 服务就会向事件队列发送一个最终的事件消息。

事件使得开发者可以用一种乐观的方式来实现高可用。比如，即便 fee 服务出现故障，order 服务仍旧能够创建订单。当 fee 服务恢复后，它可以继续处理积压的事件。我们可以将这个方法扩展到回滚的场景中：如果由于金额不足导致 fee 服务收费失败，fee 服务可以发送一个 ChargeFailed 事件，然后其他服务就可以消费该事件来取消下单操作。

这种方式称为**编排**：每个服务可以在不了解整个流程结果的情况下响应各种事件，独立执行各种操作。

## Saga

Saga 模式一种基本的用法就是采用**编排方案**：

- Saga 是一组互相协作的本地事务序列；
- 在 Saga 中，每一步的操作都是由前一个步骤所触发的

最初在 1987 年的论文中对 Saga 进行了描述，指出它是一种用于处理数据库系统中那些耗时特别长的事务（long-lived transaction）的方法。在分布式事务中，对耗时特别长的事务加锁会降低系统的可用性——而 Saga 会通过一连串相互交错的、单个的事务来解决。

在 Saga 中，我们会用补偿操作来撤销之前的操作，并让系统恢复到更一致些的状态。系统不保证一定会恢复到最初的状态；具体的操作要依赖于业务含义。

**注意：**

- Saga 本质上就是通过一系列的事件抛出，来驱动事务的完成，并在某个节点执行失败的时候，可以进行补偿，而补偿又分为正向补偿和负向补偿。
- 因为是基于事件和补偿，所以 Saga 只满足最终一致性。
- 又因为 Saga 没有做隔离，所以中间态容易被感知，导致一个实体被多个事务交织。例如一个订单的修改和删除，同时操作。
- 补偿操作可能不是及时的。一个例子是如果某个动作需要发送邮件，那么邮件实际已经发送过了，这个邮件即便补偿也是无法撤回的。正确的补偿操作应该是再发一份邮件通知被取消。

通过 Saga 的执行方式，分为：

- 编排型 Saga
- 编配型 Saga
- 交织型 Saga

### 编排型 Saga

看看下单出售股票的例子，以更好地了解如何在微服务中应用 Saga 编排模式。

该示例中，Saga 中的动作都是编排过的：每个动作 Tx 的执行都是在回应另一个动作，但是这个过程并不需要一个总指挥或者总协调人。

- T1 —— 创建订单；
- T2 —— account transaction 服务预留股票仓位；
- T3 —— fee 服务计算和收取相应的费用；
- T4 —— market 服务将购买订单提交到市场；
- T5 —— 更新所提交的订单的状态。

![](assets/epub_31151874_138.jfif)

分别解释一下这五个步骤：

- （1）order 服务执行 T1，发出 OrderCreated 事件消息。
- （2）fee 服务、account transaction 服务以及 market 服务消费这个 OrderCreated 事件消息。
- （3）fee 服务和 account transaction 服务执行对应的动作（T2 和 T3），然后分别发出事件消息，market 服务会消费这两个事件消息。
- （4）当订单的前提条件都满足以后，market 服务将订单发布到市场上（T4），然后发出 OrderPlaced 事件消息。
- （5）order 服务消费 OrderPlaced 事件消息然后更新订单的状态（T5）。

每个任务都可能会失败——在这种情况下，应用需要回滚到一个合理且一致的状态。每个服务都有一个补偿动作：

- C1 —— 取消客户创建的订单；
- C2 —— 撤销预留的股票仓位；
- C3 —— 撤销手续费并退还给客户；
- C4 —— 取消发布到市场上的订单；
- C5 —— 撤销订单的状态。

这些补偿的操作也是基于事件的。比如：

- 假设将订单发布到市场上时出现了故障，market 服务会发送一个 OrderFailed 事件来取消这个订单；
- Saga 中的其他所有服务都会消费这个事件消息；
- 在收到这个事件后，每个服务会执行相应的行动：
  - order 服务会取消客户的订单；
  - transaction 服务会取消预留的股票；
  - fee 服务会将撤销收取的费用，依次执行 C1、C2、C3 的动作。

![](assets/epub_31151874_139.jfif)

这种回滚形式的目的是让系统在语义上达到一致，而非数学意义上的一致。

系统将一个操作回滚后并不一定能恢复到和之前完全一样的状态。假设计算手续费的任务会发送一封邮件，但我们并不能将邮件撤回，所以就需要重新发送一封确认错误的邮件来代替，并告诉客户 fee 服务收取的手续费会退回到账户中。

一个流程中的每个动作可能有多个对应的补偿动作。这种方式会增加系统复杂度，这种复杂度不仅存在于预测失败场景并提前做好准备上，还体现在编码和测试上。尤其是因为交互牵涉的服务越多，回滚的复杂度可能就越高。

优点：

- 因为参与交互的各个服务之间不需要明确知道对方的存在，这也就确保了它们之间是松耦合的。
- 相应地，这也提高了每个服务的自治性。

缺点：

- 没有哪个代码片段能完整体现下单流程的整个执行过程。
- 增加验证和测试的难度，因为这些验证工作会被分摊到不同的服务上。
- 它同时还增加了状态管理的复杂度：每个服务需要在处理订单的过程中反映出不同的状态，比如，order 服务必须跟踪订单是否被创建、发布、取消、拒绝等。
- 引入服务的循环依赖问题：order 服务会发出事件消息供 market 服务消费，但是，反过来，它也会消费 market 服务发出的事件消息。这种循环依赖会导致在发布阶段服务之间是相互耦合在一起的。

### 编配型 Saga

在编配型 Saga 中，会有一个服务承担编配器或者协调器的功能：它会执行和跟踪跨多服务的 Saga 及其结果。

编配器唯一的职责就是管理 Saga 的执行。它会通过异步事件或者请求-响应的消息方式来与 Saga 中的各个参与方进行交互。最重要的是，它应该跟踪流程中每个步骤的执行状态——有时这也被称作 Saga 日志。

我们把 order 服务当作 Saga 协调器：

![](assets/epub_31151874_141.jfif)

order 服务需要跟踪下单过程中每个步骤的执行情况。

为了便于理解，我们可以将协调器类比为一种状态机：

- 一系列的状态以及状态间的转换。
- 协作方的每个响应都会触发协调器的状态发生变化，进而一步步推动协调器达到 Saga 的结果。

Saga 并不总都是成功的。在编配式的 Saga 中，协调器负责在事务执行失败后启动合适的调解动作（补偿），来让受影响的实体恢复到有效且一致的状态。

假设 market 服务不能将订单提交到市场上了。这时，编配器（order 服务）就会启动补偿动作：

- 向 account transaction 服务发起请求来撤销之前预留的股票；
- 向 fee 服务发起请求取消之前从客户那边收取的费用；
- 修改订单的状态来反映 Saga 的结果，例如修改成：拒绝或者失败。具体取决于业务逻辑（以及失败的订单是否要展示给客户或者重试）。

![](assets/epub_31151874_142.jfif)

**注意：**

- 需要记住的是，补偿动作不都是即时生效的或者同时完成的。比如，如果手续费是从客户的信用卡中收取的，那么银行可能需要花一周的时间才会撤销这笔费用。

优点：

- 将 Saga 顺序性的业务逻辑集中到单个服务中，能够让开发者更加容易地分析和推断 Saga 的当前进展和结果，而且更加易于修改 Saga 的执行顺序。
- 这种方式也简化了每个服务的工作，降低了这些服务所需要管理的状态的复杂度，因为业务逻辑都移到了协调器中。

缺点：

- 将太多的业务逻辑移到协调器中。极端情况下，这会使得其他服务变得越来越“贫血”。

**编配式方案在社区中正变得越来越普遍，特别是在开发一些执行时间比较长的交互时。**

### 交织型 Saga

不同于 ACID 类型的事务，Saga 并不具备隔离性。每个本地事务（动作）的结果对其他事务而言都是立即可见的。

这种可见性意味着一个给定的实体可能会同时参与到多个并行的 Saga 中。因此，开发者在设计业务逻辑时，就需要提前预见到这种中间态并处理这种问题。

这种事务交叉导致的复杂度主要依赖于底层业务逻辑的性质。

假设一位客户突然提交了一个订单然后又想取消掉，如果是在订单提交到市场上之前发起了这个请求（这时候下单的 Saga 还依旧处于执行中），那么这个新的指令可能就需要中断这个 Saga。

![](assets/epub_31151874_144.jfif)

处理这种 Saga 交叉的情况有 3 种常用的策略：

- 短路
- 加锁
- 中断

#### 短路

在订单还处于其他 Saga 中时，开发者可以阻止发起新的 Saga。

比如客户只能在 market 服务将订单发布到市场后才能取消这个订单。

对用户来说，这并不是一个好的办法，但却是最容易实现的策略。

#### 加锁

开发者可以使用锁来控制对实体的访问。

如果不同的 Saga 想要修改实体的状态，就需要等待获取实体对应的锁。

我们已经见过这种例子：对股票余额进行了预留或者加锁，以确保客户不能将一个有效订单中的股份出售两次。

如果不同的 Saga 相互阻止对方获取锁，就可能导致死锁，所以需要开发者实现死锁监控方案和超时方案，以保证系统不会慢慢停下来。

#### 中断

最后，开发者可以中断正在执行的动作。

比如，开发者可以将订单状态修改为 “失败（failed）”。

这样，在 market 网关收到消息要求把这个订单发布到市场上时，它可以再次验证订单的最新状态，以保证这个订单还是可以提交的，这时它会看到一个 “失败（failed）” 的状态。这种方式增加了业务逻辑的复杂度，但是避免了死锁的风险。

### 一致性模式

尽管 Saga 严重依赖于补偿操作，但并不是在服务交互中要保证一致性所唯一能选择的方案。

到目前为止，我们已经见到了两种处理失败的模式：

- 补偿动作（将买咖啡的钱退回）
- 重试（再次制作一杯咖啡）

这里展示了其他几种策略：

名称 | 策略
-|-
补偿动作 | 执行操作来撤销之前的操作
重试 | 反复重试直到成功
忽略 | 在出现错误时，什么都不做
重启 | 重置回最初状态，然后重新开始
临时操作 | 执行一个临时操作，然后稍后确认或取消

### 事件溯源

迄今为止，我们都是假设实体状态和事件是两个不同的东西：

- 前者是存储在对应的事务中的；
- 后者是独立发布的。

![](assets/epub_31151874_146.jfif)

另一种可选的方案就是**事件溯源**（event sourcing）模式：

- 完全用对象身上所发生的一系列的事件来表示状态
- 不用实体状态信息来表示所发布的事件消息

如果想要获取某个实体在指定时间的状态，开发者就需要聚合在此之前的所有事件。

比如，设想这样的order服务：

- 在传统的持久化方案中，我们一直都是假定数据库存储的是订单最新的状态；
- 在事件溯源的方案中，我们保存的是订单状态的修改事件，我们可以通过复现这些事件来获取订单当前的具体状态。

![](assets/epub_31151874_147.jfif)

这种架构可以解决企业应用中一个很普遍的问题：

- 系统是如何达到当前状态的。
- 它消除了状态和事件之间的区别；
- 开发者不再需要在业务逻辑之上插上一个个事件消息，因为业务逻辑天生地就会生成和操作事件。

但另一方面，这使得一些复合型查询变得更加困难：

- 开发者需要另外实现一些用来支持按字段和值来进行关联和过滤的数据视图，因为事件存储格式只支持按照主键来获取实体信息。

## 分布式世界的查询操作

数据所有权的去中心化同样使得获取数据变得越来越困难，因为我们不再可以通过数据库层面的 join 关联这样的方式来聚合相关的数据。

在应用的 **UI 层**展示来自于不同服务的数据通常是必要的功能。

假设开发者正在开发一个能够展示客户列表的管理界面，界面上同时还会显示这些客户当前没有完成的订单：

- 在单体应用中，共享相同的 SQL 数据库，因此开发者可以在一个查询语句中使用 JOIN 关联两张表，然后返回一个数据集。
- 在微服务应用中，这种组合通常是在 **API 层**实现的（老实说，应该属于前文提到的聚合服务）：
  - 会由一个服务或者 API 网关执行这个组合操作。
  - 关联 ID（简单类比于关系型数据库中的外键）可以确定每个服务所拥有的数据之间的关系，比如，每个订单会记录所关联的客户 ID。

API 层面的数据组合：

![](assets/epub_31151874_148.jfif)

两步法在单个实体或者小的数据集上还是可行的，但是对于批量请求而言，这种方法可扩展性很差：

- 如果第一个查询返回了 N 个客户，那么第二个查询就要执行 N 次，这种方法很快就会失控。

我们可以通过引入批量查询接口来改进查询性能：

- 不同于获取所有客户信息，我们可以只获取第一页数据；
- 不同于一个个地获取每个客户的订单，我们可以使用一个 ID 列表来获取所有数据。

```txt
/customers?page=1&size=20         ⇽---  应该对大的数据集进行分页
/orders?customerIds=4,5,10,20     ⇽---  应该使用 IN 语义来获取子节点而非一个个地获取
```

尽管如此，但如果每个客户都有上百个订单，那么对这些订单分页查询同样也会增加大量的开销。

API 组合的方式简单且直观，对于许多使用场景，比如单个聚合或者查询少量的枚举型的数据，这种查询方式的性能还是可以接受的。

但是，对于下面的一些场景，这种方式的性能就会变得很差，很不理想：

- （1）返回和关联大量数据的查询，比如报表——需要所有客户去年的订单。
- （2）跨多个服务进行分析或者聚合的查询——想要知道35岁以上的客户购买的新兴市场股票的订单的平均值。
- （3）服务所使用的数据库对某些查询方式支持效果不理想——比如，在关系型数据库中，某些复杂的搜索模式通常是难以优化的（比如SQL数据库中进行全文检索）。

最后，数据组合会受到可用性的影响：

- 数据组合需要同步调用下层服务，所以一个查询请求的整体可用性是这个过程中所有服务的可用性的乘积。

比如，如果的两个服务和 API 网关的可用性分别是 99%，那么在查询时，整体的可用性就是 99%^3，总体可用性为：97.02%。

### 保存数据副本

开发者可以选择将其他服务通过事件消息发出的数据持久化保存或者缓存起来。

比如，在 fee 服务收到 OrderCreated 事件消息后，fee 服务可以选择将这个订单的详细数据保存下来，而非仅仅保存关联 ID：

![](assets/epub_31151874_151.jfif)

这样，fee 服务就可以处理诸如 “这个订单的金额是多少” 这样的查询请求，而不再需要另外调用 order 服务来获取这个数据。

这种技术非常有用，但是也存在一些风险：

- 维护数据的多个副本增加了整个应用和服务的复杂度（很可能还包括整体的存储成本）；
- 修改事件消息的格式会变得相当棘手难以处理，因为服务和事件消息的内容耦合得越来越紧；
- 缓存失效是众所周知的难题。

将标准化数据保存到多个位置中，然后通过异步事件来更新，但是由于事件会存在延迟、失败或者重复发送的问题，开发者不得不处理最终一致性问题以及获取到的数据副本可能已经过期的问题。

**注意：**

- 可用性优先。如果在开发系统时，将可用性放在第一位，那么开发者在面对问题时就需要避免那种本能的、面向一致性的解决方案。
- 即便某些系统看起来应该将一致性作为第一优先级，但是为了最大限度地提高使用的成功率，也往往会优先选择可用性作为折中的办法。
- 自动柜员机（ATM）就是一个很好的例子——将可用性放在第一优先级能够增加银行的收入。如果一台 ATM 机或者更大范围的 ATM 网络不能连接银行后台，我们仍旧可以在 ATM 机器上取款，但是会有金额限制，以确保控制透支的风险。如果某位客户提款出现透支问题，银行会另外扣除一定的手续费。

### 查询和命令分离

在许多系统中，查询和写数据有很大的不同：

- 写数据影响的是单一的、高度规范化的实体；
- 查询通常是会从一系列的数据源中获取非规范化的数据。

有些查询模式会受益于使用与写数据完全不同的数据存储。比如：

- 开发者可能会使用 PostgreSQL 作为持久化的事务存储，但是使用 Elasticsearch 作为索引查询的数据存储。
- 这种命令-查询职责分离（CQRS）模式是一种应用于这种场景的通用模型，它显式地将系统中的读（查询）和写（命令）进行分离。

这种被称为 CQRS 架构：

![](assets/epub_31151874_155.jfif)

具体而言：

- （1）应用的命令部分执行系统的更新操作——创建、修改和删除。命令会发出事件消息，可以是内部的事件消息，也可以时发到不同的事件总线上的事件，如 RabbitMQ 或 Kafka。
- （2）事件处理器消费这些事件，以构建合适的查询或者读模型。
- （3）系统的“命令”和“查询”这两部分分别由不同的数据存储来提供支持。

我们可以在**服务内部**应用这种模式，也可以在**整个应用层面**应用这种模式（即区分更新和读的服务）。

对此，我们可以使用事件消息来构建一些专门的**查询服务**，让这些服务维护一些应用层面的复合型的数据视图。比如：

- 假设需要汇总所有账户的订单手续费，并且要按照不同的属性（如订单类型、资产类别、支付方式）进行分类汇总。
- 仅仅在单个服务层面是不可能完成这个功能的，因为不管是 fee 服务、order 服务还是 customer 服务，它们都不拥有全量的数据来支持按照那些属性过滤，每个服务只有一部分数据。
- 相反，我们可以构建一个 CustomerOrder 的查询服务来组织对应的数据视图。在不确定这些数据视图属于哪个服务时，单独维护一个查询服务是很有效的办法，这样能够确保对关注点合理地划分。

![](assets/epub_31151874_156.jfif)

在微服务应用中，CQRS 有两大核心优势：

- 第一，可以针对特定的查询请求优化其查询模型来提升它们的性能，并消除了对跨服务的 join 关联的需要；
- 第二，有助于在服务和整体应用层面实现关注点分离。

### CQRS 挑战

在 CQRS 模式中，服务的命令状态天然地会先于查询状态而得到更新，由于这种复制延迟（replication lag）的存在使得开发者需要考虑最终一致性。

因为查询模型是通过事件来更新的，所以对数据的查询可能返回的是过期的数据。

这可能会带来非常糟糕的用户体验：假设用户更新了某个订单的金额，但是单击“确定”按钮时，用户看到的还是之前的订单的数据！

![](assets/epub_31151874_159.jfif)

在这种场景中，开发者可以采用 3 种策略：

- 乐观更新
- 轮询
- 发布-订阅

![](assets/epub_31151874_161.jfif)

**注意：**

- 我个人认为，这些都不是太好的方式。其实在《实现领域驱动设计》一书中已经提到，写服务至少需要提供一个读接口：根据 ID 来读取。
- 所以，对于订单流这类重要的数据，直接到写服务去读取更佳。

#### 乐观更新

开发者应该根据命令所预期的结果来乐观地更新界面的内容。

如果命令执行失败，可以将界面的状态回滚。比如：

- 假设用户对 Instagram 上的一个内容点了 “like”，在 Instagram 后台成功保存这个修改之前，App 就已经显示出一个红心图标了。
- 如果最后后台保存失败，Instagram 会撤销界面上的这个改动（取消红心图标的显示），这样用户就需要再次 “like” 一下来显示出红心图标。

这种方式依赖于开发者拥有更新界面的所有信息，或者开发者能够根据输入数据得出这些信息。所以在用于一些简单场景时，这种方式效果最好。

#### 轮询界面

可以一直轮询对应的查询 API，直到所期望的修改生效。

在启动一个命令时，客户端可以设置一个版本号，如时间戳。对于后续的查询，客户端可以一直轮询，直到服务器返回的版本号等于或者大于指定的这个版本号，这表示查询数据模型已经成功更新体现了最新的状态。

#### 发布-订阅

不同于一直轮询修改结果，界面也可以在查询模型上订阅一些事件——比如，通过 Web socket。

在这种情况下，只有在读模型发出了 “updated” 事件以后，界面才会更新。

正如大家看到的，想要全面理解 CQRS 是比较困难的，它需要大家采用一种不同于之前处理常规的 CRUD API 时的思维方式。但是，在微服务应用中，CQRS 确实很有用的。如果应用得当，CQRS 有助于确保查询功能的性能和可用性，即便数据和功能是隶属于不同服务的不同数据存储上的。

### 分析和报表

我们还可以将 CQRS 技术推广到其他使用场景中，比如数据分析和报表。

我们可以将一连串的微服务事件消息转换然后保存到数据仓库中：

![](assets/epub_31151874_162.jfif)
