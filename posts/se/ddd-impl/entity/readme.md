# 实体

[TOC]

## 概览

于我个人理解，分析建模得到的领域模型，不应该区分实体或值对象，因为领域模型是对问题域的建模，而实体以及值对象是在实现阶段才会进行考虑的。

因此，我认为 DDD 中的实体，是在分析建模完成后，在出数据模型前，或者在代码实现类层面，进行的区分。

> 当我们需要考虑一个对象的个性特征，或者需要区分不同的对象时，我们引入实体这个领域概念。

实体允许在其生命周期内发生改变，因此这引出了实体的两大特征：

1. 唯一的身份标识
1. 可变性

这两个特征也是实体和值对象的区别。

> 我们通过标识对对象进行区分，而不是属性，此时我们应该将标识作为主要的模型定义。同时，我们需要保持简单的类定义，并且关注对象在其生命周期中的连续性和唯一标识性。我们不应该通过对象的状态形式和历史来区分不同的实体对象。

## 实体唯一标识

在设计实体时，我们应该首先考虑实体的本质特征，特别是实体的唯一标识。

我们通过什么来记录唯一标识？我们可以通过**值对象**记录唯一标识，因为值对象是不变的，这也可以保证实体身份的稳定性，同时也可以处理与身份 ID 相关的行为（因为 ID 可能并非就是个随机数或自增数，完全包含了时间、机器 IP 等信息）。

以下是一些常用的创建实体身份标识的策略：

1. 用户提供一个或多个初始唯一值作为输入。
1. 程序内部通过算法自动生成的身份标识。
1. 持久化存储生成的唯一标识。
1. 另一个限界上下文决定出的唯一标识，作为程序的输入。

### 用户提供

若用户提供的输入是唯一的（业务上要求），那么很自然的就可以使用用户输入作为唯一标识（例如用户输入身份证号，游戏昵称等）。

这样的复杂性主要是用户自己生成很高质量的标识：标识很可能是不正确的。

例如若用户输入的名字作为唯一标识，那么用户在输入并点击确定后，发现名字拼写错误，需要修改怎么办？这样的代价是比较大的。

因此，这也的方式慎用。若同时满足以下条件，则也可以使用该方法：

1. 标识将来会继续使用，不会发生变化。
1. 有工作审批流来确保标识的正确性。

### 应用程序生成

这个其实比较常见的，现在主流喜欢使用 UUID 的方式进行生成，可参考 [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)。

UUID 的生成通常而言是比较快的，但是其仍然需要调用系统函数（例如获取当前时间、随机数等）。若对于性能要求很高的场景，还可以这么做：

- 将 UUID 实例缓存起来，使其在背后不断的向缓存中填入新的 UUID 值。

因为 UUID 是随机的，所以即便系统宕机导致缓存的 UUID 丢失，也不会有什么影响。

除了 UUID，我们也可以使用一些更具可读性的标识：

```java
// AMP 表示敏捷项目管理上下文
// P 表示产品 Product
// 08-14-2012 表示创建时间
// F36AB21C 是一个随机字符串，可以取自 UUID
String rawId = "AMP-P-08-14-2012-F36AB21C";

ProductId productId = new ProductId(rawId);

Date productCreationDate = productId.creationDate();
```

这也的标识即满足唯一性，又具备可读性。同时，标识不使用原始字符串作为对象，而是专门用一个 `ProductId` 的对象，这也可以方便获取其中的一些有价值的数据。

```java
public class Product extends Entity {
    private ProductId productId;

    public Date creationDate() {
        return this.productId().creationDate();
    }
}
```

对于标识的创建，我们可以使用**资源库**的形式：

```java
// 当然，领域代码中使用的是 ProductRepository 对象来获取的 ID

public class HibernateProductRepository implements ProductRepository {
    public ProductId nextIdentity() {
        return new ProductId(java.util.UUID.randomUUID().toString().toUpperCase());
    }
}
```

### 持久化机制生成

### 另一个上下文提供

### 标识生成时间

### 委派标识

### 标识稳定性

## 发现实体

### 实体本质特征

### 实体关键行为

### 实体的角色和职责

## 创建实体

## 验证实体

### 验证实体属性

### 验证实体整体对象

### 验证对象组合