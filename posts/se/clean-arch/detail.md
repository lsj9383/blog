# 实现细节

[TOC]

## 概述

既然我们知道什么是架构以后，我们来看看什么是实现细节，这些细节应该处于架构的最外层的部分。

## 数据库是实现细节

从系统架构的角度来看，数据库并不重要——它只是一个实现细节，在系统架构中并不占据重要角色。

**注意：**

- 这里说的数据库，并不是数据模型。数据模型对于系统架构来说当然是很重要的，因为这涉及关键业务数据。
- 数据库并不是数据模型，数据库只是一款软件，是用来存取数据的工具。
- 工具通常是无关紧要的——因为这只是一个底层的实现细节，一种达成目标的手段。

一个优秀的架构师是不会让实现细节污染整个系统架构的。

### 关系型数据库

关系型数据库的基本原理是 Edgar Codd 在 1970 年定义的，并在 20 世纪 80 年代成为数据存储设计的主流：

> 由于关系模型优雅、自律、非常稳健，因此得到了非常广泛的应用。总之，关系型数据库是一种非常优秀的数据存储与访问技术。

但不管关系型数据库的设计有多么有智慧，多么精巧，多么符合数学原理，它仍然也只是一种技术。换句话说，它终究只是一种实现细节：

- 虽然关系型数据的表模型设计对某一类数据访问需要来说可能很方便，但是把数据按行组织成表结构本身并没有什么系统架构意义上的重要性。
- 应用程序的用例不应该知道，也不应该关心这么低层次的实现细节，需要了解数据表结构的代码应该被局限在系统架构的最外圈、最低层的工具函数中。
- 很多数据访问框架允许将数据行和数据表以对象的形式在系统内部传递。但是这么做在系统架构上来说是完全错误的，这会导致程序的用例、业务逻辑、甚至 UI 与数据的关系模型相互绑定在一起。

### 数据库的流行

数据库流行的起点在于优化硬盘的性能：

- 为了应对硬盘访问速度带来的限制，必须使用索引、缓存以及查询优化器等技术。
- 同时，我们还需要一种数据的标准展现格式，以便让索引、缓存及查询优化器来使用。

数据库提供的是一种便于进行内容检索的存储方式。其最擅长的是根据某些共同属性而检索一系列记录。

### 但性能怎么办呢？

性能难道不是系统架构的一个考量标准吗？

- 当然是，但当问题涉及数据存储时，这方面的操作通常是被封装起来，隔离在业务逻辑之外的。
- 也就是说，我们确实需要从数据存储中快速地存取数据，但这终究只是一个底层实现问题。

所以，对于数据库性能，我们完全可以在数据访问这一较低的层面上解决这个问题，而不需要让它与系统架构相关联。

## Web 是实现细节

Web 技术的兴起，会让一些程序员鄙视老的客户端/服务器架构，但是事实上并没有改变任何东西，或者说它也没有能力改变任何东西。

是软件行业从 1960 年来经历了很多振荡：

- 一会儿将全部计算资源集中在中央服务器上。
- 一会儿又将计算资源分散到各个终端上。

即便 Web 技术普及后，仍然存在这样的振荡：

- 一开始我们以为计算资源应该集中在服务器集群中，浏览器应该保持简单。
- 随后我们又开始在浏览器中引入 Applets。
- 再后来我们又改了主意，发明了 Web 2.0，用 Ajax 和 JavaScript 将很多计算过程挪回浏览器中。
- 我们先是非常兴奋地将整个应用程序挪到浏览器去执行，后来又非常开心地采用 Node 技术将那些 JavaScript 代码挪回服务器上执行。

### 无尽的钟摆

我们似乎永远也决定不了应该将计算资源放在哪里。我们不停地在集中式和分布式之间来回切换。

但从 IT 技术发展历史的整体来看，我们会发现 Web 技术的出现并没有改变任何东西。

作为一名系统架构师，我们应该把眼光放长远一点，这些振荡只是短期问题，不应该把它们放在系统的核心业务逻辑中来考虑。

### 钟摆总结

GUI 只是一个实现细节。而 Web 则是 GUI 的一种，所以也是一个实现细节。

作为一名软件架构师，我们需要将这类细节与核心业务逻辑隔离开来。

## 框架是实现细节

框架的设计者初衷通常是好的，并且经常会免费提供框架，帮助社区，回馈社会，但是框架作者并不能为你面临的问题提供最佳方案。这是理所当然的，框架作者并不了解你。

框架作者通常会解决，他们自己、身边、社区遇到的问题，这些问题可能和你所遇到的问题有很多重复，这也因此框架才可能会被推广开。

### 单向婚姻

我们与框架作者之间的关系是非常不对等的：

- 我们要采用某个框架就意味着自己要遵守一大堆约定
- 框架作者却完全不需要为我们遵守什么约定。

这是一种单向婚姻：我们要承担所有的风险，而框架作者则没有任何风险。

这最终会导致对于框架过于依赖，而无法离开框架。

### 框架风险

那么我们要承担的风险究竟有哪些呢？

我们可以想到的至少有以下这几项：

- 框架自身的架构设计很多时候并不是特别正确的。
- 框架本身可能经常违反依赖关系原则。譬如，框架可能会要求我们将代码引入到业务对象中——甚至是业务实体中。
- 框架可能会想要我们将框架耦合在最内圈代码中。而我们一旦引入，就再也不会离开该框架了，这就像戴上结婚戒指一样，从此一生不离不弃了。
- 框架本身可能朝着我们不需要的方向演进。也许我们会被迫升级到一个并不需要的新版本，甚至会发现自己之前所使用的旧功能突然消失了，或悄悄改变了行为。

### 框架解决方案

> 请不要嫁给框架！

我们可以使用框架——但要时刻警惕，别被它拖住。我们应该将框架作为架构最外圈的一个实现细节来使用，不要让它们进入内圈。

不要让框架污染我们的核心代码，应该依据依赖关系原则，将它们当作核心代码的插件来管理。

### 不得不接受的依赖

有一些框架是避免不了使用的：
- 如果你在用 C++，那么 STL 就是很难避免使用的。
- 如果你在用 Java，那么标准类库也是不太可能避免使用的。

这很正常——但这仍然应该是你主动选择的结果。你必须明白，如果一旦在项目中引入一个框架，很有可能在整个生命周期中都要依赖于它，不管后来情形怎么变化，这个决定都很难更改了。因此，不应该草率地做出决定。
