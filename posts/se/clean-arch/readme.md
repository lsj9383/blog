# 《整洁架构之道》笔记

[TOC]

## 概览

本文是对[《整洁架构之道》](https://weread.qq.com/web/bookDetail/480322f072021a3248038c8)一书的学习记录。

### 设计与架构

我们为什么要设计一个好的架构？目标是什么？

> 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。

那我们为什么需要减少成本呢？很明显，我们做一个事情的目的其实就是：**赚钱**。

> 利润 = 收入 - 成本

这里收入是因业务发展带来的，成本则是对系统的维护成本，因此我们要尽可能多的获得利润，就需要尽可能多的减少成本。

通常而言，在项目早期，因为业务发展较快，往往会忽略成本（也应该忽略，避免过度设计），但是随着时间的发展，历史债务越积越高，而当收入趋于稳定时就很难 cover 住成本了。

每行变更成本：

![](assets/1.png)

我们知道为什么要进行架构设计了，那么“架构”这个词，到底代表什么意思呢？

这是个很有趣的问题，《架构整洁之道》全书都在提架构，甚至自己也问出了*架构是什么？*这样的问题，但是从未给过答案。

**架构**一词，在软件工程业界似乎从未达成过一致。

在 [Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) 一文中提及：

> 尽管软件架构作为一个研究领域吸引了很多人的兴趣，但是对于什么应该被纳入架构的定义，研究者们几乎从未达成过共识。

另外，在《企业应用架构模式》中也提到：

> 很多人试图给“架构”下定义，而这些定义本身很难统一。

对于**架构**，人们的潜在共识只有两点：

1. 较高层面的系统分解或视图
1. 系统中不容易变化的部分

### 两个价值维度

正如前面提到的：`利润 = 收入 - 成本`。

这本质上可以划分成两个不同的价值维度：

价值维度 | 本质 | 到底是什么？| 价值
-|-|-|-
行为价值 | 收入 | 业务需求 | 紧急，但是不一定都重要。
架构价值 | 成本 | 灵活性（易修改、易维护）| 重要，但是不一定都紧急。

看起来一开始就设计一个好的架构是非常重要的，这看起来和当下的 MVP（最简可行产品） 理念冲突，但是本质上并不冲突，因为：

- MVP 就代表了未来有极大的变化可能，留足灵活性，以及足够的考虑，才能应对未来的变化。

就像书中提到的：

> 如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为 0。

![](assets/2.png)

但是其实很多人认为（包括我），并不需要预先就选择非常灵活且完备的架构，而是选择适合当下且应对未来足够长时间（例如一年）的一种架构即可，例如当前数据较小用单库单表就能支撑，但是未来可能会进行分库分表，这就会涉及到**数据架构**的调整。但是：

- 《架构整洁之道》一书这里有做取巧，因为它并没有说架构到底是什么，分库分表到底算架构吗？还是算一种实现？在书中其实可以看出，对数据库、对框架的选型其实没有算在架构里面，而是一种实现细节。
- 这个取巧可以认为有道理，也可以认为没道理，因为没有人能说清楚架构到底是什么，只知道架构是一种比较重要、高层面的东西，但是到底多高层面算高呢？只能由架构设计者来说明了。

## 编程范式

## 设计原则

OOA、OOD、OOP 的最基本元素就是对象，以及对象的抽象：类。

这里提到的设计原则，本质上就是对类的设计的原则：SOLID。

提到原则，那么没有目标是不行的，这些原则都是围绕着设计目标服务的：

- 易修改
- 可读性好
- 可复用

原则 | 缩写 | 描述
-|-|-
单一职责原则 | SRP | 基于康威定律的一个推论：一个软件系统的最佳结构依赖于**开发**这个系统的组织的内部结构。这样，每个软件模块都有一且只有一个需要被改变的理由。
开闭原则 | OCP | 如果软件想要被容易改变，那么设计就应该允许新增代码来修改系统行为，**而非只能**修改原来的代码。
里氏替换原则 | LSP | 如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。
接口隔离原则 | ISP | 告诫软件设计师应该在设计中避免不必要的依赖。
依赖反转原则 | DIP | 高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。

**注意：**

- 我认为上述对 SRP 的描述不够准确，上述对 SRP 的描述局限于开发人员组织内部结构了，但是看下面的 SRP 章节可以知道，这更多是从用户，或者涉众（Actor）的角度来看的。
- 开发人员组织内部结构的人员，只能认为是涉众的一部分。

### 单一职责原则（SRP）

这是一个经常被误会的原则，很多时候会听到：“每个模块都应该只做一件事”。

但是很抱歉，这是错误的。最本质的理解是：

> 任何一个软件模块都应该有且仅有一个被修改的原因。

这里的软件模块一般是指的一个源代码文件，或者一组紧密相关的函数、数据结构、类。

“仅有一个被修改的原因”，也很难理解，那什么才是被修改的原因呢？通常是系统的用户用着不爽了，所以才让修改，因此更白话的说：

> 任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。

只要这些人希望对系统进行的变更是相似的，就可以归为一类：

- 一个或多个有共同需求的人。
- 通常，我们将其称为 *执行者（Actor）* 。
  
因此，SRP 最终变为：

> 任何一个软件模块都应该只对某一类执行者（Actor） 负责。

其本质上，就是对不同类型的用户，用不同的软件模块来实现他们的用例。例如：管理员和普通用户，即便是相同的功能，也要用不同的软件模块来实现，才能被成为 SRP。

**注意：**

- 这里不同类型的用户（执行者），并非是指的不同的角色。例如对于微信支付商户，可以为员工定义很多角色，但是其实都是属于“商户员工”这一类用户。
- 有时候**执行者**和**角色**的概念比较模糊，需要注意的是，角色更多强调的是对权限的管理，是一种技术手段引申而来的，而执行者反应的是领域概念。

### 开闭原则（OCP）

什么是开闭原则？

> 软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭。

**开闭原则**，是个非常抽象的概念，比较难理解，这里到底什么是开放，什么是关闭，为什么要遵循开闭原则？

在《整洁架构之道》中并未给出非常明确的答案，而简化为了：

> 设计良好的计算机软件应该易于扩展，同时抗拒修改。

这里我们参考 [Open–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)：

- 一个软件模块，能够修改、扩展，我们则称其为*开放*。
- 一个软件模块，被其他模块所依赖，我们称其为*关闭*。

为什么这种*关闭的*、*被依赖的*模块需要去抗拒修改呢？是因为修改和变更对下游模块存在影响，当依赖方过多，则影响很大，甚至风险不可控。

那怎么去修改如此**稳定（很难被修改）**的软件模块呢？通常而言，我们去依赖接口，不依赖具体实现就可以了，需要增加新功能时避免对原有的修改，而是进行继承进行扩展。

### 里氏替换原则（LSP）

LSP 的原生含义：

> 这里需要的是一种可替换性：如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。

原生的 LSP 含义更多的是一种继承关系的理解，但是在当下面向对象如此普及的今天，单纯的继承关系已经无需更多强调了。

现如今 LSP 发挥了更多在指导接口与其实现方式的设计原则：

> 一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。

这里违背可替换原则，实际上就是指的接口前后不兼容。

### 接口隔离原则（ISP）

ISP 的原生含义（参考 [Interface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)）：

> 不应强制任何代码依赖于它不使用的方法。

原生 ISP 更多是类和接口层面的设计指导，即：

> 避免大而全宽类/接口。

例如，下面这是一种宽类：

![](assets/3.png)

在这个场景中，假设：

- User1 只会用到 op1
- User2 只会用到 op2
- User3 只会用到 op3

对接口进行隔离后，对于依赖方更易用，同时隔离掉不需要的依赖（OPS 中的 op2 的变更不会导致 User1 和 User3 的重编）：

![](assets/4.png)

在架构层面，ISP 同样有意义，这个原则告诉我们：

> 任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。

### 依赖反转原则（DIP）

什么是依赖反转？

> 如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。

对于一个软件模块，或者一个类，我们建议提供一个稳定的抽象层，因为：

- 我们每次修改抽象接口的时候，一定也会去修改对应的具体实现。
- 但反过来，当我们修改具体实现时，却很少需要去修改相应的抽象接口。
- 所以我们可以认为接口比实现更稳定。

依赖反转，到底是什么反转？为什么要做反转？

在《整洁架构之道》中指出，依赖反转，是依赖方向和控制流方向进行反转。

在常规设计（不加考虑的设计）中，控制流方向就是依赖方向，例如 Application 组件需要使用 Database 组件，那么 Application 组件就会控制 Database 组件：

![](assets/dip1.drawio.png)

我们在 Application 组件中构造一个 Database 接口类，里面提供 Application 对象需要使用的 Database 接口，并在 Database 组件中去实现这个接口：

![](assets/dip2.drawio.png)

虽然从代码逻辑流来看，还是从 Application 对象跳转到的 Database 对象，但是依赖上已经反转了，这样 Application 就不用依赖 Database 的具体实现了。


有的人可能会有疑惑，为什么不把 *App Database* 接口放在 Database 组件中，这样其实 Application 对象还是依赖的接口，没有依赖具体实现，例如这样：

![](assets/dip3.drawio.png)

大家有这样的困惑是可以理解的，但是：

- 控制流和依赖流是一致的，仍然是 Application 组件依赖 Database 组件，根本不是*依赖反转*。
- 站在 Database 组件的角度，并不知道依赖方到底有谁，需要提供什么接口，那么就会提供一个大而全的接口，这样违反了 ISP。
- *App Database* 接口一定是在 Application 组件内的，反应的是 Application 实现核心逻辑需要的方法，同时 Application 组件里面有着应用的核心领域逻辑，对外部的实现细节依赖完全解耦。
- 组件提供接口是可以的，也是常见的，但是这种叫*信息隐藏*，而不是叫*依赖反转*。
- 当一个稳定的组件（被大量依赖的组件），需要提供扩展性时，那么就需要尽可能的对外提供接口。因为核心领域逻辑应该是稳定的，那么接口也应该大量的被放在 Application 组件中。

这是一个抽象工厂的依赖反转：

![](assets/5.png)
