## 软件架构

[TCO]

## 概述

正如前面所提到的，“架构” 一次的共识之一就是在讨论某些重要的事情。在《架构整洁之道》中也提到：

> “架构”这个词给人的直观感受就充满了权力与神秘感，因此谈论架构总让人有一种正在进行责任重大的决策或者深度技术分析的感觉。

要看什么是软件架构，其实需要看架构设计者的目的，不同的目的架构的含义是不一样的。《架构整洁之道》目的是：

- 可扩展性
- 可维护性

至于性能怎么样、可用性怎么样、安全性怎么样、一致性怎么样，不是《架构整洁之道》的考虑范畴，因此这里的“架构”自然不会包括数据架构、网络架构、安全架构等等。

## 什么是软件架构？

那到底什么是软件架构呢？具体工作是什么呢？什么时候进行软件架构设计呢？

这些问题，《架构整洁之道》完全没有回答第一个问题。

## 独立性

为什么我们需要设计和保持各个系统中的独立性？那我们又该如何落地呢？

这可以给我们带来以下好处：

- 将彼此的影响分开
- 将变更集中在某处
- 更好的分工，加快开发效率
- 更好的部署和运行

### 按层解耦

架构师可以通过采用单一职责原则(SRP)和共同闭包原则(CCP)，以及既定的系统设计意图来隔离那些变更原因不同的部分，集成变更原因相同的部分。

一个软件系统，不考虑其他任何用例实现，根据变更原因，就可以划分出非常明显的层次结构：

- 用户界面，变更原因肯定和业务逻辑是不相关的。
- 应用程序，变更原因和业务逻辑紧密相连。
- 领域程序，变更原因是不常变化的领域逻辑。
- 数据库，以及其所采用的查询语言，甚至表结构，这些都是系统的技术细节信息，它们与业务规则或 UI 毫无关系。

这是一个粗略的分成形式：

- UI 界面
- 应用独有的业务逻辑
- 领域普适的业务逻辑
- 基础设施

![](assets/level.drawio.png)

在后面的 “整洁架构” 中，会给出更加完善的架构分层。

### 按用例解耦

我们从整体通用软件结构的角度根据变更原因进行分层了，这是不够的，我们还需要考虑业务本身的变更原因。

业务本身是什么？就是**用例**！

为什么我们要根据用例来进行拆分呢？

- 用例是天然的功能隔离，也是天然的变更原因的隔离。
- 用例的变更速率不同。
- 用例的重要程度不同。

因此，用例其实是在水平分层的基础上进行了垂直解耦：

> 每个用例都会用到一些UI、特定应用的业务逻辑、应用无关的业务逻辑以及数据库功能。因此，我们在将系统水平切分成多个分层的同时，也在按用例将其切分成多个垂直切片。

通过这样的形式，用例之间完全可以互不影响，各自根据业务场景进行变更。

![](assets/usercase-level.drawio.png)

**注意：**

- 完全垂直的分层，会导致组件及其多，完全无法复用。
- 我们希望上层易变，底层少变，因此最终可能会是这样：

![](assets/usercase-level-2.drawio.png)

### 重复

> 架构师们经常会钻进一个牛角尖——害怕重复。

在软件领域，经常提到“消除冗余”，或者“消除重复”：

- 类似的显示应该用相同的方式来实现，方便复用
- 类似的代码应该合并起来，方便复用
- ...

大家讨厌重复造轮子。但是：

> 重复也存在着很多种情况。其中有些是真正的重复，在这种情况下，每个实例上发生的每项变更都必须同时应用到其所有的副本上。

如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复。等我们几年后再回过头来看，可能就会发现这两段代码是非常不一样的了。正是由于这样的原因，我们必须加倍小心地避免让这两个用例复用同一段代码，否则，未来再想将它们分开会面临很大的挑战。

### 解耦的模式

解耦的模式是指的什么？

> 如何将软件系统的各个部分分解开来，以及如何连接它们。

通常而言，我们有这些解耦方式：

解耦方式 | 描述 | 示例
-|-|-
源码层次 | 控制源代码模块之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要变更或重新编译。 | 静态库
部署层次 | 控制部署单元之间的依赖关系，以此来实现一个模块的变更不会导致其他模块的重新构建和部署。| 动态库
服务层次 | 将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。 | RPC、微服务

没有哪种解耦方式是最好的，而只有根据业务场景和发展现状来决定使用解耦方式：

> 一个设计良好的架构在上述过程中还应该能保护系统的大部分源码不受变更影响。对整个系统来说，解耦模式也应该是一个可选项。我们在进行大型部署时可以采用一种模式，而在进行小型部署时则可以采用另一种模式。

## 业务逻辑

什么是业务逻辑？业务逻辑非常重要，但是常常被程序员轻视，甚至自嘲 “我不过是写业务逻辑而已”：

> 严格地讲，业务逻辑就是程序中那些真正用于赚钱或省钱的业务逻辑与过程。更严格地讲，无论这些业务逻辑是在计算机上实现的，还是人工执行的，它们在省钱/赚钱上的作用都是一样的。

业务逻辑中，最重要的我们称其为 “关键业务逻辑”，关键业务逻辑使用的数据我们称为“关键业务数据”，对于这些关键业务逻辑和数据，它们和计算机系统无关（并不是因为有了计算机后才能用这个来赚钱，人来做也是可以赚钱的）。

### 业务实体

关键业务逻辑和关键业务数据是紧密相关的，所以它们很适合被放在同一个对象中处理。我们将这种对象称为“业务实体(Entity)”。

业务实体，就是在将软件中具体实现了该关键业务的部分聚合在一起，将其与自动化系统中我们所构建的其他部分隔离区分。

- 这个类独自代表了整个业务逻辑，它与数据库、用户界面、第三方框架等内容无关。
- 该类可以在任何一个系统中提供与其业务逻辑相关的服务，它不会去管这个系统是如何呈现给用户的，数据是如何存储的，或者是以何种方式运行的。

在当下，“业务实体”被“领域实体”所代替，表征业务领域的核心逻辑。

### 用例

并不是所有的业务逻辑都是一个纯粹的业务实体，例如**用例**：

> 用例本质上就是关于如何操作一个自动化系统的描述，它定义了用户需要提供的输入数据、用户应该得到的输出信息以及产生输出所应该采取的处理步骤。

用例所描述的是**某种特定应用情景下**的业务逻辑，它并非业务实体中所包含的关键业务逻辑。

这是一个业务用例的示例：

![](assets/12.png)

**注意：**

- 用例除非正式地描述了数据流入/流出接口以外，并不详细描述用户界面。
- 用例并不描述系统与用户之间的接口，它只描述该应用在某些特定情景下的业务逻辑，这些业务逻辑所规范的是用户与业务实体之间的交互方式，它与数据流入/流出系统的方式无关。
- 其实用例对象就是使用业务实体串流程的，本质上和《软件方法》中提到的 Controller 实体类似。

业务实体本身也不知道是哪个用例在使用它们，因为业务实体不依赖用例，但是用例依赖业务实体。所以：

- 业务实体属于高层概念，而用例属于低层概念。

### 请求和响应

用例类的请求和响应：

- 接收的输入应该是一个简单的**请求性数据结构**。
- 返回输出的应该是一个简单的**响应性数据结构**。

这在现在业界主要做法就是用 Protobuf。

**需要注意的是**，业务实体中也包含了关键性数据，有些开发者可能会直接使用业务实体作为请求/响应的数据结构。

毕竟，业务实体与请求/响应模型之间有很多相同的数据，但是，请一定不要这么做：

- 这两个对象存在的意义是非常、非常不一样的。随着时间的推移，这两个对象会以不同的原因、不同的速率发生变更。
- 将它们以任何方式整合在一起都是对共同闭包原则(CCP)和单一职责原则(SRP)的违反。
- 这样做的后果，往往会导致代码中出现很多分支判断语句和中间数据。

这一个比较明显的例子是 Restful 资源和领域实体（本质上就是业务实体）应该隔离：

![](assets/13.png)

## 尖叫的软件架构

一个软件系统的架构应该可以反映出来这个系统是一个做什么事情的系统（尖叫一般的说出自己为什么服务）。

在建筑行业找一些例子，例如：

- 如果这是一幅单户住宅的建筑架构图，那么我们可能会先看到一个大门，然后是一条连接到起居室的通道，同时可能还会看到一个餐厅。当我们阅读这个架构图时，应该不会怀疑这是一个单户住宅。几乎整个设计都在尖叫着告诉你：这是一个“家”。
- 如果这是一幅图书馆的建筑设计图，那么我们可能会先看到一个超大入口，然后是一个用于签到/签出的办公区，接下来是阅读区、小型会议室，以及一排排的书架区。几乎整个设计都在尖叫着跟你说：这是一个“图书馆”。

当软件系统架构，如何喊出来呢？我们查看它的顶层架构时，它们究竟是在喊“健康管理系统”、“账务系统”、“库存管理系统”，还是在喊：“Rails”、“Spring/Hibernate”、“ASP”这样的技术名词呢？

### 架构设计的主题

《Object Oriented Software Engineering》 一书中提到：

> 软件的系统架构应该为该系统的用例提供支持。这就像住宅和图书馆的建筑计划满篇都在非常明显地凸显这些建筑的用例一样，软件系统的架构设计图也应该非常明确地凸显该应用程序会有哪些用例。

因此，架构应该体现出对用例的支持，这样才能让架构尖叫的说自己是什么系统：

- 架构设计不是与框架相关的，这件事不应该是基于框架来完成的。对于我们来说，**框架只是一个可用的工具和手段，而不是一个架构所规范的内容**。
- 如果我们的架构是基于框架来设计的，它就不能基于我们的用例来设计了。

### 架构设计的核心目标

和建筑设计类似，首要目标应该是满足住宅的使用需求，而不是确保一定要用砖来构建这个房子。

> 一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整地描述用例。

良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架、数据库、Web 服务以及其他与环境相关的工具。框架应该是一个可选项，良好的架构设计应该允许用户在项目后期再决定是否采用 Rails、Spring、Hibernate、Tomcat、MySQL 这些工具。

### 框架是工具而不是生活信条

《整洁架构之道》有个非常有意思的观点：

> 框架作者往往对自己写出的框架有着极深的信念，他们所写出来的使用手册一般都是从如何成为该框架的虔诚信徒的角度来描绘如何使用这个框架的。甚至这些框架的使用者所写的教程也会出现这种传教士模式。他们会告诉你某个框架是能包揽一切、超越一切、解决一切问题的存在。

但是作者始终在提醒读者：**这不应该成为你的观点**。

我们一定要带着怀疑的态度审视每一个框架。是的，采用框架可能会很有帮助，但采用它们的成本呢？我们一定要懂得权衡如何使用一个框架，如何保护自己。无论如何，我们需要仔细考虑如何能保持对系统用例的关注，避免让框架主导我们的架构设计。

### 可测试的架构设计

如果系统架构的所有设计都是围绕着用例来展开的，并且在使用框架的问题上保持谨慎的态度，那么我们就应该可以在不依赖任何框架的情况下针对这些用例进行单元测试。

## 整洁架构

我们设计架构时，应遵循以下的考虑：

- 独立于框架：这些系统的架构并不依赖某个功能丰富的框架之中的某个函数。框架可以被当成工具来使用，但不需要让系统来适应框架。
- 可被测试：这些系统的业务逻辑可以脱离UI、数据库、Web服务以及其他的外部元素来进行测试。
- 独立于 UI：这些系统的UI变更起来很容易，不需要修改其他的系统部分。例如，我们可以在不修改业务逻辑的前提下将一个系统的UI由Web界面替换成命令行界面。
- 独立于数据库：我们可以轻易将这些系统使用的 Oracle、SQL Server 替换成 Mongo、BigTable、CouchDB 之类的数据库。因为业务逻辑与数据库之间已经完成了解耦。
- 独立于任何外部机构：这些系统的业务逻辑并不需要知道任何其他外部接口的存在。

综上，我们得到一个整洁架构理念：

![](assets/14.png)

非常明显，这里分为了四层：

- 系统级业务逻辑（关键业务逻辑、领域实体）
- 应用级业务逻辑（用例）
- 接口适配器
- 框架与驱动程序

### 依赖关系规则

心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上：

- 外层圆代表的是机制
- 内层圆代表的是策略

> 源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。

### 整洁架构分层

分层 | 本质 | 描述 | 变更
-|-|-|-
系统级业务逻辑 | 业务实体 | 封装了该应用中最通用、最高层的业务逻辑。不包括非功能性需求（例如导航方式、安全问题的修改不应该涉及这些对象） | 核心逻辑，基本不变。
应用级业务逻辑 | 用例 | 满足特定应用场景下的业务逻辑，获得输入并通过对业务实体的组织得到相应的输出。| 变更不影响业务实体，同时也不希望用例受外部因素影响。
接口适配器 | - | 将数据从对用例和业务实体而言最方便操作的格式，转化成外部系统（譬如数据库以及Web）最方便操作的格式。| 这个已经较为细节了，放在较外层。
框架与驱动程序 | - | 编写一些与内层沟通的黏合性代码 | 将这些细节放在最外层，这样它们就很难影响到其他层了。

### 跨越边界

在整洁架构的右下侧有一个架构中跨越边界的例子：

![](assets/skip-side.drawio.png)

这里存在两个方向：

- 控制流方向：它从控制器开始，穿过用例，最后执行展示器的代码。
- 源码依赖方向：向内指向用例。

本质上可以这么理解：

- **用例的输入**，提供用例交互的接口
- **用例交互**，实现用例的输入，并对接口进行实现，同时使用**用例的输出**，将数据返回出去。
- **用例的输出**，提供了用例交互的输出数据。
- 展示器，继承了用例的输出，对数据进行展示。
- 控制器，使用用例的输入提供的接口，将数据交给用例交互进行处理。

需要注意，跨越边界的数据应该是简单的，不要投机取巧地直接传递业务实体或数据库记录对象。同时，这些传递的数据结构中也不应该存在违反依赖规则的依赖关系。

这是一个常见的场景：

![](assets/16.png)

## 谦卑对象模式

谦卑对象，听名字很难理解，其实它是出自 [谦卑对象模式](https://martinfowler.com/bliki/HumbleObject.html)。没错，这其实是一种设计模式。

这种模式的目标是：

> 帮助单元测试的编写者区分容易测试的行为与难以测试的行为，并将它们隔离。

本质上很简单，就是将一个很难测试的东西，将它分为两部分：

- 非常难以测试的谦卑对象，此类对象行为非常纯粹。
- 非常容易测试的模型对象，此类对象将数据转换为谦卑对象课直接使用的。

最典型的例子，就是我们的 GUI：对于 GUI，我们很难去测定图中显示的元素是否正确，因此我们需要做两个事情，将 GUI 的整个显示逻辑分为两个部分：

- 视图（谦卑对象）
- 展示器（提供视图模型）

例如：

![](assets/sketch.png)

左图中很难直接测试混合的逻辑，因此拆分成两部分。

### 展示器与视图

谦卑对象，因其难以测试，所以我们希望它的代码越简单，越纯粹越好，达到这样的效果：一看代码就知道，完全不用测试。

因为，我们希望视图（谦卑对象）只是单纯的拿到数据，并且不对数据做任何处理，而是直接将数据进行展示。

展示器则是可测试的对象。展示器的工作是负责从应用程序中接收数据，然后**按视图的需要将这些数据格式化**，以便视图将其呈现在屏幕上。例如：

- 将 Date 类型数据，序列化为具体格式的字符串。
- 将分为单位的金额，转换为用户习惯的元为单位的金额。

![](assets/17.png)

上图中：

- View 就是谦卑对象，获取 ViewModel 的数据直接进行展示。
- Presenter 就是展示器，从用例 OutputBoundary 中获取 Output Data，并将 Output Data 根据 View 所需要的格式，转化为 View Model。

### 测试与架构

强大的可测试性是一个架构的设计是否优秀的显著衡量标准之一，谦卑对象模式就是这方面的一个非常好的例子。

我们将系统行为分割成可测试和不可测试两部分的过程，常常就也定义了**系统的架构边界**，保障了边界内的高度可测试性。

**注意：**

- 我其实感觉应该是架构可测试的边界。

## 不完全边界

构建完整的系统边界是非常麻烦的：

- 设计双向的多态边界接口
- 设计用于输入和输出的数据结构
- 管理所有相关的依赖关系

在很多情况下，一位优秀的架构师都会认为设计架构边界的成本太高了，并且这很可能导致过度设计。

那么应该如何折衷呢？我们这里就要考虑构建**不完全边界**了。

### 省掉最后一步

构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把它们构建成一个组件。

例如：在将系统中所有的接口、用于输入/输出的数据格式等每一件事都设置好之后，仍选择将它们统一编译和部署为一个组件。

其实你会发现设计工作其实没什么区别，该划分的还是做了划分，唯一的区别就是：

- 省去了版本号管理和发布管理方面的工作。

缺点：

- 组件的隔离弱化了。
- 后期如果真想要再分离组件的话，会需要不少工作量。

### 单向边界

### 策略模式

## 层次与边界

## Main 组件

Main 组件，用于创建、协调、监督其他组件的运转。

### 最细节化的部分

Main 组件是最细节化的部分，是一切的初始点，它的职责是：

- 创建所有的工厂类、策略类以及其他的全局设施。
- 最终将系统的控制权转交给最高抽象层的代码来处理。

请记住，Main 组件是整个系统中细节信息最多的组件，因为它依赖了所以具体实现。

因此，Main 组件位于整洁架构的最外圈。

## 测试边界

测试代码也是系统的一部分。甚至，测试代码有时在系统架构中的地位还要比其他部分更独特一些。

### 测试也是系统的一部分

试组件也是要遵守依赖关系原则的。因为其中总是充满了各种细节信息，非常具体：

- 测试组件视为系统架构中最外圈的程序。
- 它们始终是向内依赖的，而且系统中没有其他组件依赖于它们。

测试组件通常是一个系统中最独立的组件。为什么这么说呢？

- 系统的正常运行并不需要用到测试组件。
- 用户也不依赖于测试组件。
- 测试组件的存在是为了支持开发过程，而不是运行过程。

然而，测试组件仍然是系统中不可或缺的一个组件。事实上，测试组件在许多方面都反映了系统中其他组件所应遵循的设计模型。

### 可测试性设计

我们对于测试代码的设计，其实也是非常重要的，但是这往往被人忽略。为什么重要呢？因为测试代码如果稍不注意，就非常脆弱：

> 测试如果没有被集成到系统设计中，往往是非常脆弱的，这种脆弱性会使得系统变得死板，非常难以更改。

里的关键之处就是耦合。如果测试代码与系统是强耦合的，它就得随着系统变更而变更。哪怕只是系统中组件的一点小变化，都可能会导致许多与之相耦合的测试出现问题，需要做出相应的变更。

在业界，这被称为**脆弱的测试问题（Fragile tests problem）**。

另外，脆弱的测试还往往会让系统变得非常死板：当开发者意识到一些简单的修改就会导致大量的测试出错时，他们自然就会抵制修改。

要想解决这个问题，就必须在设计中考虑到系统的可测试性：软件设计的第一条原则——不管是为了可测试性还是其他什么东西——是不变的，就是不要依赖于多变的东西。

譬如：
- GUI 往往是多变的，因此通过 GUI 来验证系统的测试一定是脆弱的。
- 我们在系统设计与测试设计时，应该让业务逻辑不通过 GUI 也可以被测试。

（感觉还是没有根本解决，只是减少了测试范围。GUI 的测试怎么办呢，即展示器的测试）

### 测试专用 API

专门为验证业务逻辑的测试创建一个 API：

- 这个 API 应该被授予超级用户权限
- 允许测试代码可以忽视安全限制
- 绕过那些成本高昂的资源（例如数据库）
- 强制将系统设置到某种可测试的状态中

设置测试 API 是为了将测试部分从应用程序中分离出来。换句话说：这种解耦动作不只是为了分隔测试部分与 UI 部分，而是要将测试代码的结构与应用程序其他部分的代码结构分开。

当然，这种具有超级权限的测试专用API如果被部署到我们的产品系统中，可能会是非常危险的。如果要避免这种情况发生，应该将测试专用API及其对应的具体实现放置在一个单独的、可独立部署的组件中。