## 软件架构

[TCO]

## 概述

正如前面所提到的，“架构” 一次的共识之一就是在讨论某些重要的事情。在《架构整洁之道》中也提到：

> “架构”这个词给人的直观感受就充满了权力与神秘感，因此谈论架构总让人有一种正在进行责任重大的决策或者深度技术分析的感觉。

要看什么是软件架构，其实需要看架构设计者的目的，不同的目的架构的含义是不一样的。《架构整洁之道》目的是：

- 可扩展性
- 可维护性

至于性能怎么样、可用性怎么样、安全性怎么样、一致性怎么样，不是《架构整洁之道》的考虑范畴，因此这里的“架构”自然不会包括数据架构、网络架构、安全架构等等。

## 什么是软件架构？

那到底什么是软件架构呢？具体工作是什么呢？什么时候进行软件架构设计呢？

这些问题，《架构整洁之道》完全没有回答第一个问题。

## 独立性

为什么我们需要设计和保持各个系统中的独立性？那我们又该如何落地呢？

这可以给我们带来以下好处：

- 将彼此的影响分开
- 将变更集中在某处
- 更好的分工，加快开发效率
- 更好的部署和运行

### 按层解耦

架构师可以通过采用单一职责原则(SRP)和共同闭包原则(CCP)，以及既定的系统设计意图来隔离那些变更原因不同的部分，集成变更原因相同的部分。

一个软件系统，不考虑其他任何用例实现，根据变更原因，就可以划分出非常明显的层次结构：

- 用户界面，变更原因肯定和业务逻辑是不相关的。
- 应用程序，变更原因和业务逻辑紧密相连。
- 领域程序，变更原因是不常变化的领域逻辑。
- 数据库，以及其所采用的查询语言，甚至表结构，这些都是系统的技术细节信息，它们与业务规则或 UI 毫无关系。

这是一个粗略的分成形式：

- UI 界面
- 应用独有的业务逻辑
- 领域普适的业务逻辑
- 基础设施

![](assets/level.drawio.png)

在后面的 “整洁架构” 中，会给出更加完善的架构分层。

### 按用例解耦

我们从整体通用软件结构的角度根据变更原因进行分层了，这是不够的，我们还需要考虑业务本身的变更原因。

业务本身是什么？就是**用例**！

为什么我们要根据用例来进行拆分呢？

- 用例是天然的功能隔离，也是天然的变更原因的隔离。
- 用例的变更速率不同。
- 用例的重要程度不同。

因此，用例其实是在水平分层的基础上进行了垂直解耦：

> 每个用例都会用到一些UI、特定应用的业务逻辑、应用无关的业务逻辑以及数据库功能。因此，我们在将系统水平切分成多个分层的同时，也在按用例将其切分成多个垂直切片。

通过这样的形式，用例之间完全可以互不影响，各自根据业务场景进行变更。

![](assets/usercase-level.drawio.png)

**注意：**

- 完全垂直的分层，会导致组件及其多，完全无法复用。
- 我们希望上层易变，底层少变，因此最终可能会是这样：

![](assets/usercase-level-2.drawio.png)

### 重复

> 架构师们经常会钻进一个牛角尖——害怕重复。

在软件领域，经常提到“消除冗余”，或者“消除重复”：

- 类似的显示应该用相同的方式来实现，方便复用
- 类似的代码应该合并起来，方便复用
- ...

大家讨厌重复造轮子。但是：

> 重复也存在着很多种情况。其中有些是真正的重复，在这种情况下，每个实例上发生的每项变更都必须同时应用到其所有的副本上。

如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复。等我们几年后再回过头来看，可能就会发现这两段代码是非常不一样的了。正是由于这样的原因，我们必须加倍小心地避免让这两个用例复用同一段代码，否则，未来再想将它们分开会面临很大的挑战。

### 解耦的模式

解耦的模式是指的什么？

> 如何将软件系统的各个部分分解开来，以及如何连接它们。

通常而言，我们有这些解耦方式：

解耦方式 | 描述 | 示例
-|-|-
源码层次 | 控制源代码模块之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要变更或重新编译。 | 静态库
部署层次 | 控制部署单元之间的依赖关系，以此来实现一个模块的变更不会导致其他模块的重新构建和部署。| 动态库
服务层次 | 将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信。 | RPC、微服务

没有哪种解耦方式是最好的，而只有根据业务场景和发展现状来决定使用解耦方式：

> 一个设计良好的架构在上述过程中还应该能保护系统的大部分源码不受变更影响。对整个系统来说，解耦模式也应该是一个可选项。我们在进行大型部署时可以采用一种模式，而在进行小型部署时则可以采用另一种模式。
